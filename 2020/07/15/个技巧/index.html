<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dingqi-save.github.io","root":"/","scheme":"Gemini","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta name="description" content="前言Vue 3.x 的Pre-Alpha 版本。后面还有 Alpha、Beta 等版本,要等到之后才有可能发布 3.0 新版，所以应该趁还没出来加紧打好 Vue2.x 的基础。 Vue基本用法很容易上手,但是有很多优化的写法你就不一定知道了,本文从列举了36个vue开发技巧，后续Vue 3.x出来后持续更新。">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue 开发必须知道的 36 个技巧">
<meta property="og:url" content="https://dingqi-save.github.io/2020/07/15/%E4%B8%AA%E6%8A%80%E5%B7%A7/index.html">
<meta property="og:site_name" content="一条酸菜鱼">
<meta property="og:description" content="前言Vue 3.x 的Pre-Alpha 版本。后面还有 Alpha、Beta 等版本,要等到之后才有可能发布 3.0 新版，所以应该趁还没出来加紧打好 Vue2.x 的基础。 Vue基本用法很容易上手,但是有很多优化的写法你就不一定知道了,本文从列举了36个vue开发技巧，后续Vue 3.x出来后持续更新。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-07-15T11:53:18.000Z">
<meta property="article:modified_time" content="2020-07-15T12:38:14.213Z">
<meta property="article:author" content="dingqi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dingqi-save.github.io/2020/07/15/%E4%B8%AA%E6%8A%80%E5%B7%A7/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Vue 开发必须知道的 36 个技巧 | 一条酸菜鱼</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">一条酸菜鱼</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-关于">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-档案">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>档案</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dingqi"
      src="/images/touxiang.jpg">
  <p class="site-author-name" itemprop="name">dingqi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dingqi-Save" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dingqi-Save" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/5322292095/" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;5322292095&#x2F;" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dingqi-save.github.io/2020/07/15/%E4%B8%AA%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="dingqi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一条酸菜鱼">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Vue 开发必须知道的 36 个技巧
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-15 19:53:18 / Modified: 20:38:14" itemprop="dateCreated datePublished" datetime="2020-07-15T19:53:18+08:00">2020-07-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Vue 3.x 的Pre-Alpha 版本。后面还有 Alpha、Beta 等版本,要等到之后才有可能发布 3.0 新版，所以应该趁还没出来加紧打好 Vue2.x 的基础。</p>
<p>Vue基本用法很容易上手,但是有很多优化的写法你就不一定知道了,本文从列举了36个vue开发技巧，后续Vue 3.x出来后持续更新。</p>
<a id="more"></a>
<p>文章来源于:<br><a href="https://mp.weixin.qq.com/s?__biz=MzU2NTc4NjM5OQ==&amp;mid=2247484384&amp;idx=1&amp;sn=0000a078eb718a0fa5978e1dc2c22421&amp;chksm=fcb72190cbc0a886f68c3dcc0cfba6f044282e547a5d5a161ba25c60ba9fdf85014108711a47&amp;mpshare=1&amp;scene=23&amp;srcid=0715M4snMQIka0by9SPGhyE6&amp;sharer_sharetime=1594806861848&amp;sharer_shareid=e22f24a31ebc3c050a04c9a4e7f37053#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU2NTc4NjM5OQ==&amp;mid=2247484384&amp;idx=1&amp;sn=0000a078eb718a0fa5978e1dc2c22421&amp;chksm=fcb72190cbc0a886f68c3dcc0cfba6f044282e547a5d5a161ba25c60ba9fdf85014108711a47&amp;mpshare=1&amp;scene=23&amp;srcid=0715M4snMQIka0by9SPGhyE6&amp;sharer_sharetime=1594806861848&amp;sharer_shareid=e22f24a31ebc3c050a04c9a4e7f37053#rd</a></p>
<p>require.context()</p>
<p>场景:如页面需要导入多个组件,原始写法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> titleCom <span class="keyword">from</span> <span class="string">'@/components/home/titleCom'</span></span><br><span class="line"><span class="keyword">import</span> bannerCom <span class="keyword">from</span> <span class="string">'@/components/home/bannerCom'</span></span><br><span class="line"><span class="keyword">import</span> cellCom <span class="keyword">from</span> <span class="string">'@/components/home/cellCom'</span></span><br><span class="line">components:&#123;titleCom,bannerCom,cellCom&#125;</span><br></pre></td></tr></table></figure>

<p>这样就写了大量重复的代码,利用 require.context 可以写成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> files = <span class="built_in">require</span>.context(<span class="string">'@/components/home'</span>, <span class="literal">false</span>, /\.vue$/)</span><br><span class="line"><span class="keyword">const</span> modules = &#123;&#125;</span><br><span class="line">files.keys().forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> name = path.basename(key, <span class="string">'.vue'</span>)</span><br><span class="line">  modules[name] = files(key).default || files(key)</span><br><span class="line">&#125;)</span><br><span class="line">components:modules</span><br></pre></td></tr></table></figure>


<p>这样不管页面引入多少组件,都可以使用这个方法。</p>
<p>API 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">实际上是 webpack 的方法,vue 工程一般基于 webpack,所以可以使用</span><br><span class="line"><span class="built_in">require</span>.context(directory,useSubdirectories,regExp)</span><br><span class="line">接收三个参数:</span><br><span class="line">directory：说明需要检索的目录</span><br><span class="line">useSubdirectories：是否检索子目录</span><br><span class="line">regExp: 匹配文件的正则表达式,一般是文件名</span><br></pre></td></tr></table></figure>
<p>2、watch</p>
<p>常用用法</p>
<p>场景:表格初始进来需要调查询接口 getList(),然后input 改变会重新查询</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">  <span class="keyword">this</span>.getList()</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  inpVal()&#123;</span><br><span class="line">    <span class="keyword">this</span>.getList()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>立即执行</p>
<p>可以直接利用 watch 的immediate和handler属性简写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  inpVal:&#123;</span><br><span class="line">    handler: <span class="string">'getList'</span>,</span><br><span class="line">      immediate: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>深度监听</p>
<p>watch 的 deep 属性,深度监听,也就是监听复杂数据类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">  inpValObj:&#123;</span><br><span class="line">    handler(newVal,oldVal)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(newVal)</span><br><span class="line">      <span class="built_in">console</span>.log(oldVal)</span><br><span class="line">    &#125;,</span><br><span class="line">    deep:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时发现oldVal和 newVal 值一样; 因为它们索引同一个对象/数组,Vue 不会保留修改之前值的副本;</p>
<p>所以深度监听虽然可以监听到对象的变化,但是无法监听到具体对象里面那个属性的变化</p>
<p>14种组件通讯</p>
<p>props</p>
<p>这个应该非常属性,就是父传子的属性;props 值可以是一个数组或对象;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组:不建议使用</span></span><br><span class="line">props:[]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">props:&#123;</span><br><span class="line"> inpVal:&#123;</span><br><span class="line">  type:<span class="built_in">Number</span>, <span class="comment">//传入值限定类型</span></span><br><span class="line">  <span class="comment">// type 值可为String,Number,Boolean,Array,Object,Date,Function,Symbol</span></span><br><span class="line">  <span class="comment">// type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认</span></span><br><span class="line">  required: <span class="literal">true</span>, <span class="comment">//是否必传</span></span><br><span class="line">  <span class="keyword">default</span>:<span class="number">200</span>,  <span class="comment">//默认值,对象或数组默认值必须从一个工厂函数获取如 default:()=&gt;[]</span></span><br><span class="line">  validator:(value) &#123;</span><br><span class="line">    <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'danger'</span>].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$emit</p>
<p>这个也应该非常常见,触发子组件触发父组件给自己绑定的事件,其实就是子传父的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">  &lt;home @title=<span class="string">"title"</span>&gt;</span><br><span class="line">  <span class="comment">// 子组件</span></span><br><span class="line">  <span class="keyword">this</span>.$emit(<span class="string">'title'</span>,[&#123;<span class="attr">title</span>:<span class="string">'这是title'</span>&#125;])</span><br></pre></td></tr></table></figure>


<p>vuex</p>
<p>这个也是很常用的,vuex 是一个状态管理器；</p>
<p>是一个独立的插件,适合数据共享多的项目里面,因为如果只是简单的通讯,使用起来会比较重；</p>
<p>API</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">state:定义存贮数据的仓库 ,可通过<span class="keyword">this</span>.$store.state 或mapState访问</span><br><span class="line">getter:获取 store 值,可认为是 store 的计算属性,可通过<span class="keyword">this</span>.$store.getter 或</span><br><span class="line">       mapGetters访问</span><br><span class="line">mutation:同步改变 store 值,为什么会设计成同步,因为mutation是直接改变 store 值,</span><br><span class="line">         vue 对操作进行了记录,如果是异步无法追踪改变.可通过mapMutations调用</span><br><span class="line">action:异步调用函数执行mutation,进而改变 store 值,可通过 <span class="keyword">this</span>.$dispatch或mapActions</span><br><span class="line">       访问</span><br><span class="line">modules:模块,如果状态过多,可以拆分成模块,最后在入口通过...解构引入</span><br></pre></td></tr></table></figure>


<p>attrs和listeners</p>
<p>这两个是不常用属性,但是高级用法很常见。</p>
<p>attrs场景：如果父传子有很多值，那么在子组件需要定义多个props解决：</p>
<p>attrs获取子传父中未在 props 定义的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;home title=<span class="string">"这是标题"</span> width=<span class="string">"80"</span> height=<span class="string">"80"</span> imgUrl=<span class="string">"imgUrl"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.$attrs) <span class="comment">//&#123;title: "这是标题", width: "80", height: "80", imgUrl: "imgUrl"&#125;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>相对应的如果子组件定义了 props,打印的值就是剔除定义的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  width: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.$attrs) <span class="comment">//&#123;title: "这是标题", height: "80", imgUrl: "imgUrl"&#125;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>listeners场景：子组件需要调用父组件的方法解决：父组件的方法可以通过v-on=”listeners”传入内部组件——在创建更高层次的组件时非常有用</p>
<p>如果是孙组件要访问父组件的属性和调用方法,直接一级一级传下去就可以</p>
<p>inheritAttrs</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;home title=<span class="string">"这是标题"</span> width=<span class="string">"80"</span> height=<span class="string">"80"</span> imgUrl=<span class="string">"imgUrl"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.$attrs) <span class="comment">//&#123;title: "这是标题", width: "80", height: "80", imgUrl: "imgUrl"&#125;</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">inheritAttrs默认值为<span class="literal">true</span>，<span class="literal">true</span>的意思是将父组件中除了props外的属性添加到子组件的根节点上(说明，即使设置为<span class="literal">true</span>，子组件仍然可以通过$attr获取到props意外的属性)</span><br><span class="line">将inheritAttrs:<span class="literal">false</span>后,属性就不会显示在根节点上了</span><br></pre></td></tr></table></figure>
<p>provide和inject</p>
<p>provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中;并且这对选项需要一起使用;</p>
<p>以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件:</span></span><br><span class="line">  provide: &#123; <span class="comment">//provide 是一个对象,提供一个属性或方法</span></span><br><span class="line">    foo: <span class="string">'这是 foo'</span>,</span><br><span class="line">    fooMethod:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'父组件 fooMethod 被调用'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子或者孙子组件</span></span><br><span class="line">  inject: [<span class="string">'foo'</span>,<span class="string">'fooMethod'</span>], <span class="comment">//数组或者对象,注入到子组件</span></span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.fooMethod()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在父组件下面所有的子组件都可以利用inject</span></span><br></pre></td></tr></table></figure>

<p>provide 和 inject 绑定并不是可响应的。这是官方刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的,对象是因为是引用类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//父组件:</span></span><br><span class="line">provide: &#123;</span><br><span class="line">  foo: <span class="string">'这是 foo'</span></span><br><span class="line">&#125;,</span><br><span class="line">mounted()&#123;</span><br><span class="line">  <span class="keyword">this</span>.foo=<span class="string">'这是新的 foo'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子或者孙子组件</span></span><br><span class="line">inject: [<span class="string">'foo'</span>],</span><br><span class="line">mounted() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo) <span class="comment">//子组件打印的还是'这是 foo'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>parent和children</p>
<p>parent,父实例；children，子实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">mounted()&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.$children)</span><br><span class="line">  <span class="comment">//可以拿到 一级子组件的属性和方法</span></span><br><span class="line">  <span class="comment">//所以就可以直接改变 data,或者调用 methods 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line">mounted()&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.$parent) <span class="comment">//可以拿到 parent 的属性和方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">children和parent 并不保证顺序，也不是响应式的只能拿到一级父组件和子组件。</span><br></pre></td></tr></table></figure>


<p>$refs</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;home ref=<span class="string">"home"</span>/&gt;</span><br><span class="line"></span><br><span class="line">mounted()&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.home) <span class="comment">//即可拿到子组件的实例,就可以直接操作 data 和 methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>$root</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">  mounted()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$root) <span class="comment">//获取根实例,最后所有组件都是挂载到根实例上</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$root.$children[<span class="number">0</span>]) <span class="comment">//获取根实例的一级子组件</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$root.$children[<span class="number">0</span>].$children[<span class="number">0</span>]) <span class="comment">//获取根实例的二级子组件</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p>.sync</p>
<p>在 <a href="mailto:vue@1.x">vue@1.x</a> 的时候曾作为双向绑定功能存在，即子组件可以修改父组件中的值;</p>
<p>在 <a href="mailto:vue@2.0">vue@2.0</a> 的由于违背单项数据流的设计被干掉了;</p>
<p>在 <a href="mailto:vue@2.3.0">vue@2.3.0</a>+ 以上版本又重新引入了这个 .sync 修饰符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;home :title.sync=<span class="string">"title"</span> /&gt;</span><br><span class="line"><span class="comment">//编译时会被扩展为</span></span><br><span class="line">&lt;home :title=<span class="string">"title"</span>  @update:title=<span class="string">"val =&gt; title = val"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="comment">// 所以子组件可以通过$emit 触发 update 方法改变</span></span><br><span class="line">mounted()&#123;</span><br><span class="line">  <span class="keyword">this</span>.$emit(<span class="string">"update:title"</span>, <span class="string">'这是新的title'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>v-slot</p>
<p>slot,slot-cope,scope 在 2.6.0 中都被废弃,但未被移除；</p>
<p>作用就是将父组件的 template 传入子组件；</p>
<p>插槽分类:</p>
<p>A.匿名插槽(也叫默认插槽): 没有命名,有且只有一个：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">  &lt;todo-list&gt;</span><br><span class="line">      &lt;template v-slot:<span class="keyword">default</span>&gt;</span><br><span class="line">         任意内容</span><br><span class="line">         &lt;p&gt;我是匿名插槽 &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>template&gt;</span><br><span class="line">  &lt;<span class="regexp">/todo-list&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 子组件</span></span><br><span class="line"><span class="regexp">  &lt;slot&gt;我是默认值&lt;/</span>slot&gt;</span><br><span class="line">  <span class="comment">//v-slot:default写上感觉和具名写法比较统一,容易理解,也可以不用写</span></span><br></pre></td></tr></table></figure>


<p>B.具名插槽: 相对匿名插槽组件slot标签带name命名的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">  &lt;todo-list&gt;</span><br><span class="line">      &lt;template v-slot:todo&gt;</span><br><span class="line">         任意内容</span><br><span class="line">         &lt;p&gt;我是匿名插槽 &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>template&gt;</span><br><span class="line">  &lt;<span class="regexp">/todo-list&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/子组件</span></span><br><span class="line"><span class="regexp">  &lt;slot name="todo"&gt;我是默认值&lt;/</span>slot&gt;</span><br></pre></td></tr></table></figure>


<p>C.作用域插槽: 子组件内数据可以被父页面拿到(解决了数据只能从父页面传递给子组件)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;todo-list&gt;</span><br><span class="line"> &lt;template v-slot:todo=<span class="string">"slotProps"</span> &gt;</span><br><span class="line">   &#123;&#123;slotProps.user.firstName&#125;&#125;</span><br><span class="line"> &lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>todo-list&gt;</span><br><span class="line"><span class="comment">//slotProps 可以随意命名</span></span><br><span class="line"><span class="comment">//slotProps 接取的是子组件标签slot上属性数据的集合所有v-bind:user="user"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">&lt;slot name=<span class="string">"todo"</span> :user=<span class="string">"user"</span> :test=<span class="string">"test"</span>&gt;</span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line"> &lt;<span class="regexp">/slot&gt;</span></span><br><span class="line"><span class="regexp">data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      user:&#123;</span></span><br><span class="line"><span class="regexp">        lastName:"Zhang",</span></span><br><span class="line"><span class="regexp">        firstName:"yue"</span></span><br><span class="line"><span class="regexp">      &#125;,</span></span><br><span class="line"><span class="regexp">      test:[1,2,3,4]</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ &#123;&#123; user.lastName &#125;&#125;是默认数据  v-slot:todo 当父页面没有(="slotProps")</span></span><br></pre></td></tr></table></figure>
<p>EventBus</p>
<p>就是声明一个全局Vue实例变量 EventBus , 把所有的通信数据，事件监听都存储到这个变量上;</p>
<p>类似于 Vuex。但这种方式只适用于极小的项目;</p>
<p>原理就是利用on和emit 并实例化一个全局 vue 实现数据共享</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在 main.js</span></span><br><span class="line">  Vue.prototype.$eventBus=<span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传值组件</span></span><br><span class="line">  <span class="keyword">this</span>.$eventBus.$emit(<span class="string">'eventTarget'</span>,<span class="string">'这是eventTarget传过来的值'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收组件</span></span><br><span class="line">  <span class="keyword">this</span>.$eventBus.$on(<span class="string">"eventTarget"</span>,v=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'eventTarget'</span>,v);<span class="comment">//这是eventTarget传过来的值</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>可以实现平级,嵌套组件传值,但是对应的事件名eventTarget必须是全局唯一的。</p>
<p>broadcast和dispatch</p>
<p>vue 1.x 有这两个方法,事件广播和派发,但是 vue 2.x 删除了，下面是对两个方法进行的封装</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">componentName, eventName, params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = child.$options.componentName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name === componentName) &#123;</span><br><span class="line">      child.$emit.apply(child, [eventName].concat(params));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      broadcast.apply(child, [componentName, eventName].concat(params));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    dispatch(componentName, eventName, params) &#123;</span><br><span class="line">      <span class="keyword">var</span> parent = <span class="keyword">this</span>.$parent;</span><br><span class="line">      <span class="keyword">var</span> name = parent.$options.componentName;</span><br><span class="line">      <span class="keyword">while</span> (parent &amp;&amp; (!name || name !== componentName)) &#123;</span><br><span class="line">        parent = parent.$parent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">          name = parent.$options.componentName;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">        parent.$emit.apply(parent, [eventName].concat(params));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    broadcast(componentName, eventName, params) &#123;</span><br><span class="line">      broadcast.call(<span class="keyword">this</span>, componentName, eventName, params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>路由传参</p>
<p>方案一</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 路由定义</span></span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/describe/:id'</span>,</span><br><span class="line">  name: <span class="string">'Describe'</span>,</span><br><span class="line">  component: Describe</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 页面传参</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">  path: <span class="string">`/describe/<span class="subst">$&#123;id&#125;</span>`</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 页面获取</span></span><br><span class="line"><span class="keyword">this</span>.$route.params.id</span><br></pre></td></tr></table></figure>


<p>方案二</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由定义</span></span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/describe'</span>,</span><br><span class="line">  name: <span class="string">'Describe'</span>,</span><br><span class="line">  component: Describe</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 页面传参</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">  name: <span class="string">'Describe'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    id: id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 页面获取</span></span><br><span class="line"><span class="keyword">this</span>.$route.params.id</span><br></pre></td></tr></table></figure>


<p>方案三</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由定义</span></span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/describe'</span>,</span><br><span class="line">  name: <span class="string">'Describe'</span>,</span><br><span class="line">  component: Describe</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 页面传参</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">  path: <span class="string">'/describe'</span>,</span><br><span class="line">    query: &#123;</span><br><span class="line">      id: id</span><br><span class="line">  <span class="string">`&#125;</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">// 页面获取</span></span><br><span class="line"><span class="string">this.$route.query.id</span></span><br></pre></td></tr></table></figure>

<p>三种方案对比，方案二参数不会拼接在路由后面,页面刷新参数会丢失；</p>
<p>方案一和三参数拼接在后面,丑,而且暴露了信息。</p>
<p>Vue.observable</p>
<p>用法:让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象;</p>
<p>返回的对象可以直接用于渲染函数和计算属性内，并且会在发生改变时触发相应的更新;</p>
<p>也可以作为最小化的跨组件状态存储器，用于简单的场景。通讯原理实质上是利用Vue.observable实现一个简易的 vuex</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 文件路径 - /store/store.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = Vue.observable(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  setCount (count) &#123;</span><br><span class="line">    store.count = count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;label <span class="keyword">for</span>=<span class="string">"bookNum"</span>&gt;数 量&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button @click="setCount(count+1)"&gt;+&lt;/</span>button&gt;</span><br><span class="line">            &lt;span&gt;&#123;&#123;count&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button @click="setCount(count-1)"&gt;-&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; store, mutations &#125; <span class="keyword">from</span> <span class="string">'../store/store'</span> <span class="comment">// Vue2.6新增API Observable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Add'</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> store.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    setCount: mutations.setCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>


<p>render 函数</p>
<p>场景:有些代码在 template 里面写会重复很多,所以这个时候 render 函数就有作用啦</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 根据 props 生成标签</span></span><br><span class="line"><span class="comment">// 初级</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-<span class="keyword">if</span>=<span class="string">"level === 1"</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span> &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p v-else-if="level === 2"&gt; &lt;slot&gt;&lt;/</span>slot&gt; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h1 v-else-if="level === 3"&gt; &lt;slot&gt;&lt;/</span>slot&gt; &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h2 v-else-if="level === 4"&gt; &lt;slot&gt;&lt;/</span>slot&gt; &lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;strong v-else-if="level === 5"&gt; &lt;slot&gt;&lt;/</span>slot&gt; &lt;<span class="regexp">/stong&gt;</span></span><br><span class="line"><span class="regexp">    &lt;textarea v-else-if="level === 6"&gt; &lt;slot&gt;&lt;/</span>slot&gt; &lt;<span class="regexp">/textarea&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 优化版,利用 render 函数减小了代码重复率</span></span><br><span class="line"><span class="regexp">&lt;template&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;child :level="level"&gt;Hello world!&lt;/</span>child&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">'text/javascript'</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">  Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="keyword">const</span> tag = [<span class="string">'div'</span>, <span class="string">'p'</span>, <span class="string">'strong'</span>, <span class="string">'h1'</span>, <span class="string">'h2'</span>, <span class="string">'textarea'</span>][<span class="keyword">this</span>.level<span class="number">-1</span>]</span><br><span class="line">      <span class="keyword">return</span> h(tag, <span class="keyword">this</span>.$slots.default)</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      level: &#123;  <span class="attr">type</span>: <span class="built_in">Number</span>,  <span class="attr">required</span>: <span class="literal">true</span>  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)   </span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'hehe'</span>,</span><br><span class="line">    data() &#123; <span class="keyword">return</span> &#123; <span class="attr">level</span>: <span class="number">3</span> &#125; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>



<p>  render 和 template 的对比前者适合复杂逻辑,后者适合逻辑简单;</p>
<p>  后者属于声明是渲染，前者属于自定Render函数;</p>
<p>  前者的性能较高，后者性能较低。</p>
<p>  异步组件</p>
<p>  场景:项目过大就会导致加载缓慢,所以异步组件实现按需加载就是必须要做的事啦</p>
<p>  异步注册组件3种方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂函数执行 resolve 回调</span></span><br><span class="line">Vue.component(<span class="string">'async-webpack-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个特殊的 `require` 语法将会告诉 webpack</span></span><br><span class="line">  <span class="comment">// 自动将你的构建代码切割成多个包, 这些包</span></span><br><span class="line">  <span class="comment">// 会通过 Ajax 请求加载</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'./my-async-component'</span>], resolve)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数返回 Promise</span></span><br><span class="line">Vue.component(</span><br><span class="line">  <span class="string">'async-webpack-example'</span>,</span><br><span class="line">  <span class="comment">// 这个 `import` 函数会返回一个 `Promise` 对象。</span></span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数返回一个配置化组件对象</span></span><br><span class="line"><span class="keyword">const</span> AsyncComponent = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span></span><br><span class="line">  component: <span class="keyword">import</span>(<span class="string">'./MyComponent.vue'</span>),</span><br><span class="line">  <span class="comment">// 异步组件加载时使用的组件</span></span><br><span class="line">  loading: LoadingComponent,</span><br><span class="line">  <span class="comment">// 加载失败时使用的组件</span></span><br><span class="line">  error: ErrorComponent,</span><br><span class="line">  <span class="comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span></span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 如果提供了超时时间且组件加载也超时了，</span></span><br><span class="line">  <span class="comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span></span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>异步组件的渲染本质上其实就是执行2次或者2次以上的渲染, 先把当前组件渲染为注释节点,</p>
<p>当组件加载成功后, 通过 forceRender 执行重新渲染。</p>
<p>或者是渲染为注释节点, 然后再渲染为loading节点, 在渲染为请求完成的组件</p>
<p>路由的按需加载</p>
<p>  webpack&lt; 2.4 时<br>  {<br>    path:’/‘,<br>    name:’home’,<br>    components:resolve=&gt;require([‘@/components/home’],resolve)<br>  }</p>
<p>  webpack&gt; 2.4 时<br>  {<br>    path:’/‘,<br>    name:’home’,<br>    components:()=&gt;import(‘@/components/home’)<br>  }</p>
<p>  import()方法由es6提出，import()方法是动态加载，返回一个Promise对象，then方法的参数是加载到的模块。类似于Node.js的require方法，主要import()方法是异步加载的。</p>
<p>动态组件</p>
<p>场景:做一个 tab 切换时就会涉及到组件动态加载</p>
<p><component v-bind:is="currentTabComponent"></component></p>
<p>但是这样每次组件都会重新加载,会消耗大量性能,所以 就起到了作用</p>
  <keep-alive>
    <component v-bind:is="currentTabComponent"></component>
  </keep-alive>
这样切换效果没有动画效果,这个也不用着急,可以利用内置的

  <transition>
  <keep-alive>
    <component v-bind:is="currentTabComponent"></component>
  </keep-alive>
  </transition>


<p>递归组件</p>
<p>场景:如果开发一个 tree 组件,里面层级是根据后台数据决定的,这个时候就需要用到动态组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归组件: 组件在它的模板内可以递归的调用自己，只要给组件设置name组件就可以了。</span></span><br><span class="line"><span class="comment">// 设置那么House在组件模板内就可以递归使用了,不过需要注意的是，</span></span><br><span class="line"><span class="comment">// 必须给一个条件来限制数量，否则会抛出错误: max stack size exceeded</span></span><br><span class="line"><span class="comment">// 组件递归用来开发一些具体有未知层级关系的独立组件。比如：</span></span><br><span class="line"><span class="comment">// 联级选择器和树形控件</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-<span class="keyword">for</span>=<span class="string">"(item,index) in treeArr"</span>&gt;</span><br><span class="line">      子组件，当前层级值：&#123;&#123;index&#125;&#125; &lt;br/&gt;</span><br><span class="line">      &lt;!-- 递归调用自身, 后台判断是否不存在改值 --&gt;</span><br><span class="line">      &lt;tree :item=<span class="string">"item.arr"</span> v-<span class="keyword">if</span>=<span class="string">"item.flag"</span>&gt;&lt;<span class="regexp">/tree&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 必须定义name，组件内部才能递归调用</span></span><br><span class="line"><span class="regexp">  name: 'tree',</span></span><br><span class="line"><span class="regexp">  data()&#123;</span></span><br><span class="line"><span class="regexp">    return &#123;&#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 接收外部传入的值</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">     item: &#123;</span></span><br><span class="line"><span class="regexp">      type:Array,</span></span><br><span class="line"><span class="regexp">      default: ()=&gt;[]</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>


<p>递归组件必须设置name 和结束的阀值。</p>
<p>函数式组件</p>
<p>定义:无状态,无法实例化，内部没有任何生命周期处理方法</p>
<p>规则:在 2.3.0 之前的版本中，如果一个函数式组件想要接收 prop，则 props 选项是必须的。</p>
<p>在 2.3.0 或以上的版本中，你可以省略 props 选项，所有组件上的特性都会被自动隐式解析为 prop ；</p>
<p>在 2.5.0 及以上版本中，如果你使用了单文件组件(就是普通的.vue 文件),可以直接在 template 上声明functional组件需要的一切都是通过 context 参数传递。</p>
<p>context 属性有:</p>
<p>props：提供所有 prop 的对象；</p>
<p>children: VNode 子节点的数组；</p>
<p>slots: 一个函数，返回了包含所有插槽的对象；</p>
<p>scopedSlots: (2.6.0+) 一个暴露传入的作用域插槽的对象。也以函数形式暴露普通插槽；</p>
<p>data：传递给组件的整个数据对象，作为 createElement 的第二个参数传入组件；</p>
<p>parent：对父组件的引用；</p>
<p>listeners: (2.3.0+) 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是 data.on 的一个别名；</p>
<p>injections: (2.3.0+) 如果使用了 inject 选项，则该对象包含了应当被注入的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template functional&gt;</span><br><span class="line">  &lt;div v-<span class="keyword">for</span>=<span class="string">"(item,index) in props.arr"</span>&gt;&#123;&#123;item&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">components和 Vue.component</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">components:局部注册组件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  components:&#123;home&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.component:全局注册组件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'home'</span>,home)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.extend</span><br></pre></td></tr></table></figure>


<p>场景:vue 组件中有些需要将一些元素挂载到元素上,这个时候 extend 就起到作用了是构造一个组件的语法器</p>
<p>写法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建构造器</span></span><br><span class="line"><span class="keyword">var</span> Profile = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;&#123;&#123;extendData&#125;&#125;&lt;/br&gt;实例传入的数据为:&#123;&#123;propsExtend&#125;&#125;&lt;/p&gt;'</span>,<span class="comment">//template对应的标签最外层必须只有一个标签</span></span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      extendData: <span class="string">'这是extend扩展的数据'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props:[<span class="string">'propsExtend'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建的构造器可以挂载到元素上,也可以通过 components 或 Vue.component()注册使用</span></span><br><span class="line"><span class="comment">// 挂载到一个元素上。可以通过propsData传参.</span></span><br><span class="line"><span class="keyword">new</span> Profile(&#123;<span class="attr">propsData</span>:&#123;<span class="attr">propsExtend</span>:<span class="string">'我是实例传入的数据'</span>&#125;&#125;).$mount(<span class="string">'#app-extend'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 components 或 Vue.component()注册</span></span><br><span class="line">Vue.component(<span class="string">'Profile'</span>,Profile)</span><br></pre></td></tr></table></figure>

<p>mixins</p>
<p>场景:有些组件有些重复的 js 逻辑,如校验手机验证码,解析时间等,mixins 就可以实现这种混入</p>
<p>mixins 值是一个数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mixin=&#123;</span><br><span class="line">    created()&#123;</span><br><span class="line">      <span class="keyword">this</span>.dealTime()</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      dealTime()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'这是mixin的dealTime里面的方法'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  mixins:[mixin]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>extends</p>
<p>extends用法和mixins很相似,只不过接收的参数是简单的选项对象或构造函数,所以extends只能单次扩展一个组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> extend=&#123;</span><br><span class="line">    created()&#123;</span><br><span class="line">      <span class="keyword">this</span>.dealTime()</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      dealTime()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'这是mixin的dealTime里面的方法'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  extends:extend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.use()</span><br></pre></td></tr></table></figure>


<p>场景:我们使用 element时会先 import,再 Vue.use()一下,实际上就是注册组件,触发 install 方法;这个在组件调用会经常使用到;会自动组织多次注册相同的插件.</p>
<p>install</p>
<p>场景:在 Vue.use()说到,执行该方法会触发 install是开发vue的插件,这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象(可选)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyPlugin = &#123;&#125;;</span><br><span class="line">  MyPlugin.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2. 添加全局资源,第二个参数传一个值默认是update对应的值</span></span><br><span class="line">    Vue.directive(<span class="string">'click'</span>, &#123;</span><br><span class="line">      bind(el, binding, vnode, oldVnode) &#123;</span><br><span class="line">        <span class="comment">//做绑定的准备工作,添加时间监听</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'指令my-directive的bind执行啦'</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      inserted: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//获取绑定的元素</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'指令my-directive的inserted执行啦'</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      update: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//根据获得的新值执行对应的更新</span></span><br><span class="line">      <span class="comment">//对于初始值也会调用一次</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'指令my-directive的update执行啦'</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      componentUpdated: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'指令my-directive的componentUpdated执行啦'</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      unbind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//做清理操作</span></span><br><span class="line">      <span class="comment">//比如移除bind时绑定的事件监听器</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'指令my-directive的unbind执行啦'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 注入组件</span></span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">      created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'注入组件的created被调用啦'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'options的值为'</span>,options)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">    Vue.prototype.$myMethod = <span class="function"><span class="keyword">function</span> (<span class="params">methodOptions</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'实例方法myMethod被调用啦'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调用MyPlugin</span></span><br><span class="line">  Vue.use(MyPlugin,&#123;<span class="attr">someOption</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.挂载</span></span><br><span class="line">  <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>


<p>更多请戳 vue中extend，mixins，extends，components,install的几个操作</p>
<p>Vue.nextTick</p>
<p>场景:页面加载时需要让文本框获取焦点用法:在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mounted()&#123; <span class="comment">//因为 mounted 阶段 dom 并未渲染完毕,所以需要$nextTick</span></span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs.inputs.focus() <span class="comment">//通过 $refs 获取dom 并绑定 focus 方法</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Vue.directive</p>
<p>使用</p>
<p>场景:官方给我们提供了很多指令,但是我们如果想将文字变成指定的颜色定义成指令使用,这个时候就需要用到Vue.directive</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局定义</span></span><br><span class="line">Vue.directive(<span class="string">"change-color"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">el,binding,vnode</span>)</span>&#123;</span><br><span class="line">  el.style[<span class="string">"color"</span>]= binding.value;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div v-change-color=“color”&gt;&#123;&#123;message&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      <span class="keyword">return</span>&#123;</span><br><span class="line">        color:<span class="string">'green'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>


<p>生命周期</p>
<p>bind 只调用一次，指令第一次绑定到元素时候调用，用这个钩子可以定义一个绑定时执行一次的初始化动作。</p>
<p>inserted:被绑定的元素插入父节点的时候调用(父节点存在即可调用，不必存在document中)</p>
<p>update: 被绑定与元素所在模板更新时调用，而且无论绑定值是否有变化，通过比较更新前后的绑定值，忽略不必要的模板更新</p>
<p>componentUpdate :被绑定的元素所在模板完成一次更新更新周期的时候调用</p>
<p>unbind: 只调用一次，指令月元素解绑的时候调用</p>
<p>Vue.filter</p>
<p>场景:时间戳转化成年月日这是一个公共方法,所以可以抽离成过滤器使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// 在双花括号中</span></span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 `v-bind` 中</span></span><br><span class="line">&lt;div v-bind:id=<span class="string">"rawId | formatId"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 全局注册</span></span><br><span class="line"><span class="regexp">Vue.filter('stampToYYMMDD', (value) =&gt;&#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 处理逻辑</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 局部注册</span></span><br><span class="line"><span class="regexp">filters: &#123;</span></span><br><span class="line"><span class="regexp">  stampToYYMMDD: (value)=&gt; &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 处理逻辑</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 多个过滤器全局注册</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ /</span>src/common/filters.js</span><br><span class="line"><span class="keyword">let</span> dateServer = <span class="function"><span class="params">value</span> =&gt;</span> value.replace(<span class="regexp">/(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)/g</span>, <span class="string">'$1-$2-$3'</span>)</span><br><span class="line"><span class="keyword">export</span> &#123; dateServer &#125;</span><br><span class="line"><span class="comment">// /src/main.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> custom <span class="keyword">from</span> <span class="string">'./common/filters/custom'</span></span><br><span class="line"><span class="built_in">Object</span>.keys(custom).forEach(<span class="function"><span class="params">key</span> =&gt;</span> Vue.filter(key, custom[key]))</span><br></pre></td></tr></table></figure>



<p>Vue.compile</p>
<p>场景:在 render 函数中编译模板字符串。只在独立构建时有效</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = Vue.compile(<span class="string">'&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">'hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  render: res.render,</span><br><span class="line">  staticRenderFns: res.staticRenderFns</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>Vue.version</p>
<p>场景:有些开发插件需要针对不同 vue 版本做兼容,所以就会用到 Vue.version</p>
<p>用法:Vue.version()可以获取 vue 版本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> version = <span class="built_in">Number</span>(Vue.version.split(<span class="string">'.'</span>)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (version === <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">// Vue v2.x.x</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (version === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// Vue v1.x.x</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Unsupported versions of Vue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Vue.set()</p>
<p>场景:当你利用索引直接设置一个数组项时或你修改数组的长度时,</p>
<p>由于 Object.defineprototype()方法限制,数据不响应式更新。不过vue.3.x 将利用 proxy 这个问题将得到解决。</p>
<p>解决方案:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 set</span></span><br><span class="line"><span class="keyword">this</span>.$<span class="keyword">set</span>(arr,index,item)</span><br><span class="line"></span><br><span class="line">// 利用数组 push(),splice()</span><br></pre></td></tr></table></figure>


<p>Vue.config.keyCodes</p>
<p>场景:自定义按键修饰符别名</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将键码为 113 定义为 f2</span></span><br><span class="line">Vue.config.keyCodes.f2 = <span class="number">113</span>;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> @keyup.f2=<span class="string">"add"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>Vue.config.performance</p>
<p>场景:监听性能</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.performance = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>只适用于开发模式和支持 performance.mark API 的浏览器上</p>
<p>Vue.config.errorHandler</p>
<p>场景:指定组件的渲染和观察期间未捕获错误的处理函数</p>
<p>规则:从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。</p>
<p>同样的，当这个钩子是 undefined 时，被捕获的错误会通过 console.error 输出而避免应用崩溃</p>
<p>从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了</p>
<p>从 2.6.0 起，这个钩子也会捕获 v-on DOM 监听器内部抛出的错误。</p>
<p>另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理。</p>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.errorHandler = <span class="function"><span class="keyword">function</span> (<span class="params">err, vm, info</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">  <span class="comment">// `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子</span></span><br><span class="line">  <span class="comment">// 只在 2.2.0+ 可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vue.config.warnHandler</p>
<p>场景:为 Vue 的运行时警告赋予一个自定义处理函数,只会在开发者环境下生效</p>
<p>用法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.warnHandler = <span class="function"><span class="keyword">function</span> (<span class="params">msg, vm, trace</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// `trace` 是组件的继承关系追踪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>v-pre</p>
<p>场景:vue 是响应式系统,但是有些静态的标签不需要多次编译,这样可以节省性能</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-pre&gt;&#123;&#123; <span class="keyword">this</span> will not be compiled &#125;&#125;&lt;<span class="regexp">/span&gt;   显示的是&#123;&#123; this will not be compiled &#125;&#125;</span></span><br><span class="line"><span class="regexp">&lt;span v-pre&gt;&#123;&#123;msg&#125;&#125;&lt;/</span>span&gt;     即使data里面定义了msg这里仍然是显示的&#123;&#123;msg&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>v-cloak</p>
<p>场景:在网速慢的情况下,在使用vue绑定数据的时候，渲染页面时会出现变量闪烁用法:这个指令保持在元素上直到关联实例结束编译。</p>
<p>和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template 中</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"#app"</span> v-cloak&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;value.name&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// css 中</span></span><br><span class="line">[v-cloak] &#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以解决闪烁,但是会出现白屏,这样可以结合骨架屏使用</p>
<p>v-once</p>
<p>场景:有些 template 中的静态 dom 没有改变,这时就只需要渲染一次,可以降低性能开销</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-once&gt; 这时只需要加载一次的标签&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure>

<p>v-once 和 v-pre 的区别:v-once只渲染一次；v-pre不编译,原样输出</p>
<p>事件修饰符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.stop:阻止冒泡</span><br><span class="line">.prevent:阻止默认行为</span><br><span class="line">.self:仅绑定元素自身触发</span><br><span class="line">.once: <span class="number">2.1</span><span class="number">.4</span> 新增,只触发一次</span><br><span class="line">.passive: <span class="number">2.3</span><span class="number">.0</span> 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和.prevent 一起使用</span><br></pre></td></tr></table></figure>
<p>按键修饰符和按键码</p>
<p>场景:有的时候需要监听键盘的行为,如按下 enter 去查询接口等</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对应键盘上的关键字</span></span><br><span class="line">.enter</span><br><span class="line">.tab</span><br><span class="line">.delete (捕获“删除”和“退格”键)</span><br><span class="line">.esc</span><br><span class="line">.space</span><br><span class="line">.up</span><br><span class="line">.down</span><br><span class="line">.left</span><br><span class="line">.right</span><br></pre></td></tr></table></figure>
<p>Vue-router</p>
<p>场景:Vue-router 是官方提供的路由插件</p>
<p>缓存和动画</p>
<p>路由是使用官方组件 vue-router,使用方法相信大家非常熟悉;</p>
<p>这里我就叙述下路由的缓存和动画;</p>
<p>可以用exclude(除了)或者include(包括),2.1.0 新增来判断；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;keep-alive :include=<span class="string">"['a', 'b']"</span>&gt;</span><br><span class="line">  <span class="comment">//或include="a,b" :include="/a|b/",a 和 b 表示组件的 name</span></span><br><span class="line">  <span class="comment">//因为有些页面,如试试数据统计,要实时刷新,所以就不需要缓存</span></span><br><span class="line">    &lt;router-view/&gt; <span class="comment">//路由标签</span></span><br><span class="line">  &lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp">  &lt;router-view exclude="c"/</span>&gt;</span><br><span class="line">  <span class="comment">// c 表示组件的 name值</span></span><br><span class="line">&lt;<span class="regexp">/transition&gt;</span></span><br></pre></td></tr></table></figure>


<p>（注：匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配。）</p>
<p>用 v-if 做判断,组件会重新渲染,但是不用一一列举组件 name</p>
<p>全局路由钩子</p>
<p>router.beforeEach</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'全局前置守卫：beforeEach -- next需要调用'</span>) <span class="comment">//一般登录拦截用这个,也叫导航钩子守卫</span></span><br><span class="line">  <span class="keyword">if</span> (path === <span class="string">'/login'</span>) &#123;</span><br><span class="line">    next()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (token) &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>router.beforeResolve (v 2.5.0+)和beforeEach类似，</p>
<p>区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用，即在 beforeEach之后调用；</p>
<p>router.afterEach全局后置钩子在所有路由跳转结束的时候调用这些钩子不会接受 next 函数也不会改变导航本身。</p>
<p>组件路由钩子</p>
<p>beforeRouteEnter在渲染该组件的对应路由被确认前调用，用法和参数与router.beforeEach类似，next需要被主动调用。</p>
<p>此时组件实例还未被创建，不能访问this可以通过传一个回调给 next来访问组件实例。</p>
<p>在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="comment">// 这里还无法访问到组件实例，this === undefined</span></span><br><span class="line">  next( <span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 `vm` 访问组件实例</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>beforeRouteUpdate (v 2.2+)在当前路由改变，并且该组件被复用时调用，可以通过this访问实例， next需要被主动调用，不能传回调；</p>
<p>beforeRouteLeave导航离开该组件的对应路由时调用，可以访问组件实例 this，next需要被主动调用，不能传回。</p>
<p>路由模式</p>
<p>设置 mode 属性:hash或 history</p>
<p>Vue.$router</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push():跳转到不同的url，但这个方法回向history栈添加一个记录，点击后退会返回到上一个页面</span><br><span class="line"><span class="keyword">this</span>.$router.replace():不会有记录</span><br><span class="line"><span class="keyword">this</span>.$router.go(n):n可为正数可为负数。正数返回上一个页面,类似 <span class="built_in">window</span>.history.go(n)</span><br></pre></td></tr></table></figure>

<p>Vue.$route</p>
<p>表示当前跳转的路由对象,</p>
<p>属性有:</p>
<p>name:路由名称</p>
<p>path:路径</p>
<p>query:传参接收值</p>
<p>params:传参接收值</p>
<p>fullPath:完成解析后的 URL，包含查询参数和 hash 的完整路径</p>
<p>matched:路由记录副本</p>
<p>redirectedFrom:如果存在重定向，即为重定向来源的路由的名字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$route.params.id:获取通过 params 或/:id传参的参数</span><br><span class="line"><span class="keyword">this</span>.$route.query.id:获取通过 query 传参的参数</span><br></pre></td></tr></table></figure>

<p>router-view 的 key</p>
<p>场景:由于 Vue 会复用相同组件, 即 /page/1 =&gt; /page/2 或者 /page?id=1 =&gt; /page?id=2 这类链接跳转时, 将不在执行created, mounted之类的钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view :key=<span class="string">"$route.fullPath"</span>&gt;&lt;<span class="regexp">/router-view&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样组件的 created 和 mounted 就都会执行</p>
<p>Object.freeze</p>
<p>场景:一个长列表数据,一般不会更改,但是vue会做getter和setter的转换</p>
<p>用法:是ES5新增的特性，可以冻结一个对象，防止对象被修改</p>
<p>支持:vue 1.0.18+对其提供了支持，对于data或vuex里使用freeze冻结了的对象，vue不会做getter和setter的转换</p>
<p>注意:冻结只是冻结里面的单个属性,引用地址还是可以更改</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        <span class="comment">// vue不会对list里的object做getter、setter绑定</span></span><br><span class="line">        list: <span class="built_in">Object</span>.freeze([</span><br><span class="line">            &#123; <span class="attr">value</span>: <span class="number">1</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">value</span>: <span class="number">2</span> &#125;</span><br><span class="line">        ])</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">        <span class="comment">// 界面不会有响应,因为单个属性被冻结</span></span><br><span class="line">        <span class="keyword">this</span>.list[<span class="number">0</span>].value = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面两种做法，界面都会响应</span></span><br><span class="line">        <span class="keyword">this</span>.list = [</span><br><span class="line">            &#123; <span class="attr">value</span>: <span class="number">100</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">value</span>: <span class="number">200</span> &#125;</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">this</span>.list = <span class="built_in">Object</span>.freeze([</span><br><span class="line">            &#123; <span class="attr">value</span>: <span class="number">100</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">value</span>: <span class="number">200</span> &#125;</span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">调试 template</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">场景:在Vue开发过程中, 经常会遇到template模板渲染时JavaScript变量出错的问题,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">此时也许你会通过<span class="built_in">console</span>.log来进行调试这时可以在开发环境挂载一个 log 函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line">Vue.prototype.$log = <span class="built_in">window</span>.console.log;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件内部</span></span><br><span class="line">&lt;div&gt;&#123;&#123;$log(info)&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>vue-loader 小技巧</p>
<p>preserveWhitespace</p>
<p>场景:开发 vue 代码一般会有空格,这个时候打包压缩如果不去掉空格会加大包的体积配置preserveWhitespace可以减小包的体积</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  vue: &#123;</span><br><span class="line">    preserveWhitespace: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>transformToRequire</p>
<p>场景:以前在写 Vue 的时候经常会写到这样的代码：把图片提前 require 传给一个变量再传给组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// page 代码</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;avatar :img-src=<span class="string">"imgSrc"</span>&gt;&lt;<span class="regexp">/avatar&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  export default &#123;</span></span><br><span class="line"><span class="regexp">    created () &#123;</span></span><br><span class="line"><span class="regexp">      this.imgSrc = require('./</span>assets/<span class="keyword">default</span>-avatar.png<span class="string">')</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>


<p>现在:通过配置 transformToRequire 后，就可以直接配置，这样vue-loader会把对应的属性自动 require 之后传给组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue-cli 2.x在vue-loader.conf.js 默认配置是</span></span><br><span class="line">transformToRequire: &#123;</span><br><span class="line">    video: [<span class="string">'src'</span>, <span class="string">'poster'</span>],</span><br><span class="line">    source: <span class="string">'src'</span>,</span><br><span class="line">    img: <span class="string">'src'</span>,</span><br><span class="line">    image: <span class="string">'xlink:href'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置文件,如果是vue-cli2.x 在vue-loader.conf.js里面修改</span></span><br><span class="line">  avatar: [<span class="string">'default-src'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue-cli 3.x 在vue.config.js</span></span><br><span class="line"><span class="comment">// vue-cli 3.x 将transformToRequire属性换为了transformAssetUrls</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  pages,</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config</span><br><span class="line">      .module</span><br><span class="line">        .rule(<span class="string">'vue'</span>)</span><br><span class="line">        .use(<span class="string">'vue-loader'</span>)</span><br><span class="line">        .loader(<span class="string">'vue-loader'</span>)</span><br><span class="line">        .tap(<span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">      options.transformAssetUrls = &#123;</span><br><span class="line">        avatar: <span class="string">'img-src'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> options;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// page 代码可以简化为</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;avatar img-src=<span class="string">"./assets/default-avatar.png"</span>&gt;&lt;<span class="regexp">/avatar&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure>


<p>为路径设置别名</p>
<p>场景:在开发过程中，我们经常需要引入各种文件，如图片、CSS、JS等，为了避免写很长的相对路径（../），我们可以为不同的目录配置一个别名</p>
<p>vue-cli 2.x 配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 webpack.base.config.js中的 resolve 配置项，在其 alias 中增加别名</span></span><br><span class="line">resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span>,</span><br><span class="line">      <span class="string">'@'</span>: resolve(<span class="string">'src'</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>


<p>vue-cli 3.x 配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在根目录下创建vue.config.js</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(__dirname)</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.resolve.alias</span><br><span class="line">      .set(key, value) <span class="comment">// key,value自行定义，比如.set('@@', resolve('src/components'))</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>img 加载失败</p>
<p>场景:有些时候后台返回图片地址不一定能打开,所以这个时候应该加一张默认图片</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// page 代码</span></span><br><span class="line">&lt;img :src=<span class="string">"imgUrl"</span> @error=<span class="string">"handleError"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      imgUrl:<span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    handleError(e)&#123;</span><br><span class="line">      e.target.src=reqiure(<span class="string">'图片路径'</span>) <span class="comment">//当然如果项目配置了transformToRequire,参考上面 27.2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>


<p>css</p>
<p>局部样式</p>
<p>Vue中style标签的scoped属性表示它的样式只作用于当前模块，是样式私有化；</p>
<p>渲染的规则/原理：给HTML的DOM节点添加一个 不重复的data属性来表示唯一性，</p>
<p>在对应的CSS选择器末尾添加一个当前组件的 data属性选择器来私有化样式，</p>
<p>如：.demo[data-v-2311c06a]{}如果引入 less 或 sass 只会在最后一个元素上设置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">      Vue.js scoped</span><br><span class="line">    &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style lang="less" scoped&gt;</span></span><br><span class="line"><span class="regexp">  .demo&#123;</span></span><br><span class="line"><span class="regexp">    font-size: 16px;</span></span><br><span class="line"><span class="regexp">    .content&#123;</span></span><br><span class="line"><span class="regexp">      color: red;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器渲染效果</span></span><br><span class="line">&lt;div data-v-fed36922&gt;</span><br><span class="line">  Vue.js scoped</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;style type="text/</span>css<span class="string">"&gt;</span></span><br><span class="line"><span class="string">.demo[data-v-039c5b43] &#123;</span></span><br><span class="line"><span class="string">  font-size: 14px;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">.demo .content[data-v-039c5b43] &#123; //.demo 上并没有加 data 属性</span></span><br><span class="line"><span class="string">  color: red;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure>


<p>deep 属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面样式加一个 /deep/</span></span><br><span class="line">&lt;style lang=<span class="string">"less"</span> scoped&gt;</span><br><span class="line">  .demo&#123;</span><br><span class="line">    font-size: <span class="number">14</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">  .demo /deep/ .content&#123;</span><br><span class="line">    color: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 浏览器编译后</span></span><br><span class="line"><span class="regexp">&lt;style type="text/</span>css<span class="string">"&gt;</span></span><br><span class="line"><span class="string">.demo[data-v-039c5b43] &#123;</span></span><br><span class="line"><span class="string">  font-size: 14px;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">.demo[data-v-039c5b43] .content &#123;</span></span><br><span class="line"><span class="string">  color: blue;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure>

<p>The end.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/14/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="prev" title="事件冒泡和事件捕获的区别">
      <i class="fa fa-chevron-left"></i> 事件冒泡和事件捕获的区别
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dingqi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>


  















  

  

</body>
</html>
